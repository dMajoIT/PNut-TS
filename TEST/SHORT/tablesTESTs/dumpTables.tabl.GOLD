; Generated: 01/27/2024
;	************************************************
;  ADDPINS/ADDBITS only allowed in PASM under #immediate expression
;  Allow INA/INB/etc to be used in CON expressions as register values
; ************************************************
; *                                              *
; *              Spin2 Compiler                  *
; *                                              *
; *                Version 0.1                   *
; *                                              *
; *           Written by Chip Gracey             *
; *       (C) 2006-2023 by Parallax, Inc.        *
; *          Last Updated: 2023/12/12            *
; *                                              *
; ************************************************
;
;  Version 0.0   - Adapted from SXASM v1.01
;          0.1   - Added Propeller II instructions
;
;
;
;  Public routines
;
;       27                                                          public  P2InitStruct
;       28                                                          public  P2Compile1
;       29                                                          public  P2Compile2
;       30                                                          public  P2InsertInterpreter
;       31                                                          public  P2InsertDebugger
;       32                                                          public  P2InsertFlashLoader
;       33                                                          public  P2InsertClockSetter
;       34                                                          public  P2ResetDebugSymbols
;       35                                                          public  P2ParseDebugString
;       36                                                          public  P2Disassemble
;
;
;  Equates
;
;       41           =002B                  spin2_version           =       43
;       43           =00100000              obj_limit               =       100000h         ;must be same in delphi
;       44           =0020                  file_limit              =       32              ;must be same in delphi
;       45           =0010                  param_limit             =       16              ;must be same in delphi
;       46           =03E8                  info_limit              =       1000            ;must be same in delphi
;       47           =4000                  debug_data_limit        =       4000h           ;must be same in delphi
;       48           =8000                  debug_string_limit      =       8000h           ;must be same in delphi
;       49           =044C                  debug_display_limit     =       1100            ;must be same in delphi
;       51           =1000                  ddsymbols_limit_auto    =       1000h
;       52           =1000                  ddsymbols_limit_name    =       1000h
;       54           =00010000              symbols_limit_auto      =       10000h          ;adjust as needed to accommodate auto      +
;       56           =0100                  symbols_limit_level     =       100h
;       57           =0400                  symbols_limit_param     =       400h
;       58           =00040000              symbols_limit_main      =       40000h
;       59           =8000                  symbols_limit_local     =       8000h
;       60           =8000                  symbols_limit_inline    =       8000h
;       62           =001E                  symbol_limit            =       30
;       63           =00010000              pubcon_list_limit       =       10000h
;       64           =0010                  block_nest_limit        =       16
;       65           =1000                  block_stack_limit       =       1000h
;       66           =0100                  if_limit                =       256
;       67           =0100                  case_limit              =       256
;       68           =0100                  case_fast_limit         =       256             ;cannot exceed 256
;       69           =007F                  params_limit            =       127
;       70           =000F                  results_limit           =       15
;       71           =00010238              locals_limit            =       10000h + params_limit*4 + results_limit*4
;       72           =0400                  subs_limit              =       1024
;       73           =0400                  objs_limit              =       1024
;       74           =4000                  distiller_limit         =       4000h
;       76           =0120                  inline_limit            =       120h
;       77           =01D2                  mrecv_reg               =       1D2h
;       78           =01D3                  msend_reg               =       1D3h
;       79           =01D8                  pasm_regs               =       1D8h
;       80           =01E0                  inline_locals           =       1E0h
;       82           =2A00                  debug_size_limit        =       2A00h
;       84           =0044                  clkfreq_address         =       044h
;
;
;  Macro for assigning ascending values
;
;
;
;  Macro for non-word symbol checks
;
;
;
;  Macros for automatic symbols
;
;
;
;  Assembly operands
;
;
;
;  Assembly push/pops
;
;
;
;  Assembly codes
;
;
;
;
;
;  Types
;
;
;
;  Bytecodes
;
;
;
;  Flex codes
;
;     2396           =0007                  flex_params             =       07h
;     2397           =0038                  flex_results            =       38h
;     2398           =0003                  flex_results_shift      =       3
;     2399           =0040                  flex_pinfld             =       40h
;     2400           =0080                  flex_hubcode            =       80h
;                flexcode        bytecode        params  results pinfld  hubcode
;                                                                                           +
;
;
;  Operators
;
;        Operator precedence (highest to lowest)
;
;        0       !, -, ABS, FABS, ENCOD, DECOD, BMASK, ONES, SQRT, FSQRT, QLOG, QEXP        +
;        1       >>, <<, SAR, ROR, ROL, REV, ZEROX, SIGNX                                   +
;        2       &                                                                          +
;        3       ^                                                                          +
;        4       |                                                                          +
;        5       *, *., /, /., +/, //, +//, SCA, SCAS, FRAC                                 +
;        6       +, +., -, -.                                                               +
;        7       #>, <#                                                                     +
;        8       ADDBITS, ADDPINS                                                           +
;        9       <, <., +<, <=, <=., +<=, ==, ==., <>, <>., >=, >=., +>=, >, >., +>, <=>    +
;        10      !!, NOT                                                                    +
;        11      &&, AND                                                                    +
;        12      ^^, XOR                                                                    +
;        13      ||, OR                                                                     +
;        14      ? :                                                                        +
;
;
;                                        oper            type            prec    float
;
;     2857           =000E                  ternary_precedence      =       14
;     2865           =01000000              opc_ternary     =       1 shl 24
;     2866           =02000000              opc_binary      =       1 shl 25
;     2867           =04000000              opc_unary       =       1 shl 26
;     2868           =08000000              opc_assign      =       1 shl 27
;     2869           =10000000              opc_float       =       1 shl 28
;     2870           =20000000              opc_alias       =       1 shl 29
;     2871           =40000000              opc_hubcode     =       1 shl 30
;                oc              op              prec    bytecode        ternary binary     +
;
;
;  Blocks
;
;
;
;  Directives
;
;
;
;  Ifs
;
;
;
;  Info types
;
;
;
;  Macro to establish undefined byte(s)
;
;  dbx           symbol(,count)
;
;
;
;  Macro to establish undefined word(s)
;
;  dwx           symbol(,count)
;
;
;
;  Macro to establish undefined doubleword(s)
;
;  ddx           symbol(,count)
;
;
;
; ***********
; *  Start  *
; ***********
;
;
;
; ************************************************************************
;
; ************************************************************************
;
;
;
;  Data structure
;
;
;
; ************************************************************************
;
; ************************************************************************
;
;
;
; ************************************************************************
;
; ************************************************************************
;
;
;
; ************************************************************************
;
; ************************************************************************
;
;
;
; ************************************************************************
;
; ************************************************************************
;
;
;
; ************************************************************************
;
; ************************************************************************
;
;
;
; ************************************************************************
;
; ************************************************************************
;
;
;
; ************************************************************************
;
; ************************************************************************
;
;
;
; ************************************************************************
;
; ************************************************************************
;
;
;
; ************************************************************************
;
; ************************************************************************
;
;
;
; ************************************************************************
; *  Error Handling                                                      *
; ************************************************************************
;
;
;  Compiler errors
;
;
;
;  Set error pointer and abort assembly
;
;
;
; ************************************************************************
; *  Compiler                                                            *
; ************************************************************************
;
;
;  Usage:
;
;        Call Compile1
;        Load any obj files
;        Call Compile2
;        Save new obj file
;
;
;  OBJ structure:
;
;        (file only)     long    varsize,pgmsize
;
;        0/pbase:        long    $7FFF_FFFF & OBJn offset, OBJn var offset (0 = type only)
;                        ....
;                        long    $8000_0000 | parameters << 24 | results << 20 | PUBn offset
;                        ....
;                        long    $8000_0000 | parameters << 24 | results << 20 | PRIn offset
;                        ....
;                        long    $7FFF_FFFF & objsize (past last PRIn)
;
;                        byte    DAT data...
;                        byte    PUB data...
;                        byte    PRI data...
;        objsize:
;                        /alignl
;                        \long   OBJn data...
;                        ....
;        pgmsize:
;                        byte    checksum
;
;
;
;  Compile1
;
;
;
;  Compile2
;
;
;
;  InsertInterpreter
;
;
;
;  InsertDebugger
;
;
;
;  InsertFlashLoader
;
;
;
;  InsertClockSetter
;
;
;
;  ResetDebugSymbols
;
;
;
;  ParseDebugString
;
;
;
;  Done
;
;
;
;  Data
;
;
;
; ************************************************************************
; *  Print Routines                                                      *
; ************************************************************************
;
;
;  Print obj data
;
;
;
;  Print symbol2
;
;
;
;  Print hex
;
;
;
;  Print decimal
;
;
;
;  Print string at esi
;
;
;  Print string after call
;  zero-terminated string must follow call
;
;
;
;  Print al
;
;
;
;  Set print data
;  esi must point to data
;
;
;
;  Print data
;
;
;
; ************************************************************************
; *  Info Routines                                                       *
; ************************************************************************
;
;
;  Enter info
;
;
;
; ************************************************************************
; *  High-Level Compiler Routines                                        *
; ************************************************************************
;
;
;  Determine compiler mode
;  pasm_mode is set to 0 for Spin or 1 for PASM
;
;
;
;  Determine Spin2 level
;
;
;
;  Compile con blocks
;
;
;
;  Compile obj blocks - get id's, filenames, and parameters
;
;
;
;  Compile sub blocks - id only
;
;
;
;  Compile dat blocks - filenames only
;
;
;
;  Compile obj pub/con symbols, also validates obj files
;
;
;
;  Compile var blocks
;
;
;
;  Compile dat blocks
;
;
;
;  Compile sub blocks
;
;
;
;  Compile obj data
;
;
;
;  Distill obj blocks
;
;
;
;  Collapse DEBUG data
;
;
;
;  Compile final touches
;
;
;
;  Determine download baud and debug pins and baud
;
;
;
;  Check for DEBUG-related symbol
;  esi must point to symbol name
;  c=1 if undefined, else ebx=value and z=0 if not integer constant
;
;
;
;  Insert interpreter
;
;
;
;  Insert debugger
;
;
;
;  Insert flash loader
;
;
;
;  Insert clock setter
;
;
;
;  Move obj block upward by eax bytes (reverse move)
;
;
;
;  Pad obj to next long alignment
;
;
;
;  Point to first con block
;
;
;
;  Determine clock mode and frequency
;
;
;
;  Calculate PLL setting
;
;  on entry:     eax = input frequency in Hz
;                ebx = desired output frequency in Hz
;                ecx = max allowable error in Hz
;
;  on exit:      eax = PLL mode with crystal bits cleared (eax[3:2]=0)
;                ebx = actual output frequency in Hz
;                c = 1 if setting found
;
;
;
;  Print doc data
;
;
;
; ************************************************************************
; *  Object Distiller                                                    *
; ************************************************************************
;
;
;  Distill objects
;
;
;
;  Build initial object list
;
;
;
;  Scrub sub-object offsets within objects to enable comparison of redundant objects
;
;
;
;  Eliminate redundant objects
;
;
;
;  Rebuild distilled object with sub-objects
;
;
;
;  Reconnect any sub-objects
;
;
;
;  Distiller data
;
;  3+ long records:
;
;  0:    object id
;  1:    object offset
;  2:    sub-object count
;  3:    method count
;  4:    object size
;  5+:   sub-object id's (if any)
;
;
;
; ************************************************************************
; *  Elementizer                                                         *
; ************************************************************************
;
;
;  Reset element
;
;
;
;  Get element
;
;  on entry:     source_ptr = source pointer
;
;  on exit:      eax = element type
;                ebx = element value
;                source_start = element start
;                source_finish = element finish
;                source_ptr = new source pointer
;
;                if eof, c=1
;
;
;
;  Back up one element
;
;
;
;  Check al for word character
;  c=0 if word character
;
;
;
;  Check al for digit below cl
;  c=0 if valid digit
;
;
;
;  Check al for hex digit
;  c=0 if hex digit
;
;
;
;  Make al uppercase
;
;
;
;  Get floating-point constant at edx
;
;
;
;  Get element's column +1 into [column]
;
;
;
;  Elementizer data
;
;
;
; ************************************************************************
; *  Expression Resolver                                                 *
; ************************************************************************
;
;  Resolver routines:
;
;        get_value       - Resolve expression - if error, abort
;        try_value       - bl.0 = try, bl.1 = assembly operand mode
;
;  On exit:
;
;        if resolved:            ebx=value, c=1 if float
;        if unresolvable:        ebx=0 if try, else abort
;
;  Basic expression syntax rules:                i.e.  4000 / (ABS x * 5) // 127) + 1
;
;        Any one of these...     Must be followed by any one of these...
;        ------------------------------------------------------------------
;        constant                binary operator
;        )                       )
;                                ? (ternary operator)
;                                <end>
;
;        Any one of these...     Must be followed by any one of these... *
;        ------------------------------------------------------------------
;        unary operator          constant
;        binary operator         unary operator
;        (                       (
;        ? (ternary operator)
;
;                                * initial element of an expression
;
;  Get/try value
;
;
;
;  Try to resolve Spin2 constant expression
;  c=0 if succeeded with constant in ebx
;  c=1 if failed with [source_ptr] restored
;
;
;
;  Resolve expression with sub-expressions
;
;
;
;  Check constant
;  z=1 if constant with value in ebx
;
;
;
;  Perform push/binary/unary operation
;
;
;
;  Expression resolver stack
;
;    14651           =0010                  matsize         =       10h                     ;math stack size (long)
;
;
;  QLOG/QEXP resolver
;
;  C=0 for QLOG
;  C=1 for QEXP
;
;
;
; ************************************************************************
; *  Floating-Point Operations                                           *
; ************************************************************************
;
;  Floating-point routines:
;
;        fp_fge          - force eax => ebx
;        fp_fle          - force eax <= ebx
;        fp_cmp          - compare eax to ebx
;        fp_add          - add ebx into eax
;        fp_sub          - subtract ebx from eax
;        fp_mul          - multiply ebx into eax
;        fp_div          - divide eax into ebx
;
;        fp_float        - convert eax integer to float
;        fp_round        - convert eax float to rounded integer
;        fp_trunc        - convert eax float to truncated integer
;
;
;
;  Floating-point fge (greatest(fp eax, fp ebx) -> fp eax)
;  c=1 if overflow
;
;
;
;  Floating-point fle (least(fp eax, fp ebx) -> fp eax)
;  c=1 if overflow
;
;
;
;  Floating-point comparison (fp eax - fp ebx -> overflow, zero flags)
;  c=1 if overflow
;
;
;
;  Floating-point addition/subtraction (fp eax +/- fp ebx -> fp eax)
;  c=1 if overflow
;
;
;
;  Floating-point multiply (fp eax * fp ebx -> fp eax)
;  c=1 if overflow
;
;
;
;  Floating-point divide (fp eax / fp ebx -> fp eax)
;  c=1 if overflow
;
;
;
;  Floating-point square-root (FSQRT(fp eax) -> fp eax)
;  c=1 if overflow
;
;
;
;  Convert integer to floating-point (int eax -> fp eax)
;
;
;
;  Convert float to rounded/truncated integer (fp eax -> int eax)
;  c=1 if overflow
;
;
;
;  Unpack eax
;
;  dl.0=sign, esi=exponent, eax = mantissa (bit29-justified)
;  if mantissa 0, value 0
;
;
;
;  Unpack ebx
;
;  dh.0=sign, edi=exponent, ebx = mantissa (bit29-justified)
;  if mantissa 0, value 0
;
;
;
;  Pack eax
;
;  dl.0=sign, esi=exponent, eax = mantissa (bit29-justified)
;  c=1 if overflow
;
;
;
;  Restore value pointers
;
;
;
; ************************************************************************
; *  Instruction Block Compiler                                          *
; ************************************************************************
;
;
;  Compile instruction block
;  ebp must hold column
;
;
;
;  Compile block and check for empty - TESTT not being used
;
; compile_block_check:
;
;                push    ebx
;                push    ecx
;
;
;
;
;                call    compile_block
;
;
;                je      @@error
;
;                pop     ecx
;                pop     ebx
;                ret
;
;
; @@error:       mov     [source_start],ecx
;                mov     [source_finish],ecx
;                jmp     error_bie
;
;
;  Compile block - 'if' / 'ifnot'
;
;
;
;  Compile block - 'case'
;
;
;
;  Compile block - 'case_fast'
;
;
;
;  Compile block - 'repeat'
;
;  bstack[0] = 'next' address
;  bstack[1] = 'quit' address
;  bstack[2] = loop address
;
;
;
;  Optimizing block compiler
;  eax must point to compiler routine
;  ebp must hold column
;
;
;
;  Blocknest routines
;
;
;
;  Blockstack routines
;
;
;
; ************************************************************************
; *  Instruction Compiler                                                *
; ************************************************************************
;
;
;  Compile instruction
;
;
;
;  Compile instruction - 'next'/'quit'
;  on entry: bl=0 for 'next', bl=1 for 'quit'
;
;
;
;  Compile instruction - 'return'
;
;
;
;  Compile instruction - 'abort'
;
;
;
;  Compile instruction - SEND()
;
;
;
;  Compile inline assembly section - first handle ORG operand(s)
;
;
;
;  Compile multi-variable assignment - var,... := param(s),...
;
;
;
;  Compile instruction - unary var assignment
;
;
;
; ********************************
; *  DEBUG Instruction Compiler  *
; ********************************
;
;
;  DEBUG byte commands:
;
;  00000000      end                             end of DEBUG commands
;  00000001      asm                             set asm mode
;  00000010      IF(cond)                        abort if cond = 0
;  00000011      IFNOT(cond)                     abort if cond <> 0
;  00000100      cogn                            output "CogN  " with possible timestamp
;  00000101      chr                             output chr
;  00000110      str                             output string
;  00000111      DLY(ms)                         delay for ms
;  00001000      PC_KEY(ptr)                     get key
;  00001001      PC_MOUSE(ptr)                   get mouse
;
;  ______00      ', ' + zstr + ' = ' + data      specifiers for ZSTR..SBIN_LONG_ARRAY
;  ______01             zstr + ' = ' + data
;  ______10                     ', ' + data
;  ______11                            data
;
;  001000__      <empty>
;  001001__      ZSTR(ptr)                       z-string, in quotes for show
;  001010__      <empty>
;  001011__      FDEC(val)                       floating-point
;  001100__      FDEC_REG_ARRAY(ptr,len)         floating-point
;  001101__      LSTR(ptr,len)                   length-string, in quotes for show
;  001110__      <empty>
;  001111__      FDEC_ARRAY(ptr,len)             floating-point
;
;  010000__      UDEC(val)                       unsigned decimal
;  010001__      UDEC_BYTE(val)
;  010010__      UDEC_WORD(val)
;  010011__      UDEC_LONG(val)
;  010100__      UDEC_REG_ARRAY(ptr,len)
;  010100__      UDEC_BYTE_ARRAY(ptr,len)
;  010110__      UDEC_WORD_ARRAY(ptr,len)
;  010111__      UDEC_LONG_ARRAY(ptr,len)
;
;  011000__      SDEC(val)                       signed decimal
;  011001__      SDEC_BYTE(val)
;  011010__      SDEC_WORD(val)
;  011011__      SDEC_LONG(val)
;  011100__      SDEC_REG_ARRAY(ptr,len)
;  011101__      SDEC_BYTE_ARRAY(ptr,len)
;  011110__      SDEC_WORD_ARRAY(ptr,len)
;  011111__      SDEC_LONG_ARRAY(ptr,len)
;
;  100000__      UHEX(val)                       unsigned hex
;  100001__      UHEX_BYTE(val)
;  100010__      UHEX_WORD(val)
;  100011__      UHEX_LONG(val)
;  100100__      UHEX_REG_ARRAY(ptr,len)
;  100101__      UHEX_BYTE_ARRAY(ptr,len)
;  100110__      UHEX_WORD_ARRAY(ptr,len)
;  100111__      UHEX_LONG_ARRAY(ptr,len)
;
;  101000__      SHEX(val)                       signed hex
;  101001__      SHEX_BYTE(val)
;  101010__      SHEX_WORD(val)
;  101011__      SHEX_LONG(val)
;  101100__      SHEX_REG_ARRAY(ptr,len)
;  101101__      SHEX_BYTE_ARRAY(ptr,len)
;  101110__      SHEX_WORD_ARRAY(ptr,len)
;  101111__      SHEX_LONG_ARRAY(ptr,len)
;
;  110000__      UBIN(val)                       unsigned binary
;  110001__      UBIN_BYTE(val)
;  110010__      UBIN_WORD(val)
;  110011__      UBIN_LONG(val)
;  110100__      UBIN_REG_ARRAY(ptr,len)
;  110101__      UBIN_BYTE_ARRAY(ptr,len)
;  110110__      UBIN_WORD_ARRAY(ptr,len)
;  110111__      UBIN_LONG_ARRAY(ptr,len)
;
;  111000__      SBIN(val)                       signed binary
;  111001__      SBIN_BYTE(val)
;  111010__      SBIN_WORD(val)
;  111011__      SBIN_LONG(val)
;  111100__      SBIN_REG_ARRAY(ptr,len)
;  111101__      SBIN_BYTE_ARRAY(ptr,len)
;  111110__      SBIN_WORD_ARRAY(ptr,len)
;  111111__      SBIN_LONG_ARRAY(ptr,len)
;
;
;
;
;  Compile DEBUG for Spin2
;
;
;
;  Compile DEBUG for assembler
;
;
;
;  Get debug expression source start and finish
;  eax must point to expression skipper
;
;
;
;  Enter expression string for verbose command
;
;
;
;  Enter command with first flag update
;
;
;
;  If chrs expressed in source, enter string
;
;
;
;  Enter tick-mode string
;  on entry, eax must point to start of string
;  on exit, [source_ptr] points after string
;
;
;
;  Enter byte into command buffer
;  bl must hold byte
;
;
;
;  Enter record into debug data
;  on exit, al holds BRK code
;
;
;
;  Data
;
;
;
; ************************************************************************
; *  Expression Compiler                                                 *
; ************************************************************************
;
;  Basic expression syntax rules:     i.e.  4000 / (ABS x * 5) // 127) + 1
;
;        Any one of these...     Must be followed by any one of these...
;        ------------------------------------------------------------------
;        term                    binary operator
;        )                       )
;                                ? (ternary operator)
;                                <end>
;
;        Any one of these...     Must be followed by any one of these... *
;        ------------------------------------------------------------------
;        unary operator          term
;        binary operator         unary operator
;        (                       (
;        ? (ternary operator)
;
;                                * initial element of an expression
;
;
;  Compile expression with sub-expressions and check for constant
;  z=1 if constant with value in exp_con_value and expression skipped
;
;
;
;  Compile expression with sub-expressions
;  z=1 if constant with obj ptr in con_ptr and value in con_value
;
;
;
;  Compile term
;
;
;
;  Compile term - STRING("constantstring")
;
;
;
;  Compile term - LSTRING("constantstring", zero_ok, zero_ok)
;
;
;
;  Compile term - BYTE/WORD/LONG(value, value, BYTE/WORD/LONG value)
;
;
;
;  Compile term - \obj{[]}.method({param,...}), \method({param,...}), \var({param,          +
;  if ch = 0 then method can have no results
;  if ch = 1 then method must have one result
;  if ch = 2 then method must have at least one result
;  cl must hold bc_drop_?
;
;
;
;  Compile term - obj{[]}.method({param,...}) or obj.con
;  if ch = 0 then method can have no results
;  if ch = 1 then method must have one result
;  if ch = 2 then method must have at least one result
;  cl must hold bc_drop_?
;
;
;
;  Compile term - obj{[]}.method({param,...})
;  if ch = 0 then method can have no results
;  if ch = 1 then method must have one result
;  if ch = 2 then method must have at least one result
;  cl must hold bc_drop_?
;
;
;
;  Compile term - method({param,...})
;  if ch = 0 then method can have any number of results
;  if ch = 1 then method must have one result
;  if ch = 2 then method must have at least one result
;  cl must hold bc_drop_?
;
;
;
;  Compile term - var({param,...}){:results} or RECV() or SEND(param{,...})
;  if ch = 0 then method can have any number of results
;  if ch = 1 then method must have one result
;  if ch = 2 then method must have at least one result
;  cl must hold bc_drop_?
;  edx must point to var
;
;
;
;  Compile term - LOOKUP/LOOKDOWN
;
;
;
;  Compile term - COGSPIN(cog,method(parameters),stackadr)
;
;
;
;  Compile flex instruction
;
;
;
;  Compile term - @"string", @obj{[]}.method, @method, or @hubvar
;
;
;
;  Compile term - ^@var
;
;
;
; ************************************************************************
; *  Compiler Support Routines                                           *
; ************************************************************************
;
;
;  Scan elements for type=type_block and value=dl
;  c=0 if found, c=1 if eof
;
;
;
;  Get ???
;
;
;
;  Get comma or right parenthesis
;  z=1 if comma, z=0 if right
;
;
;
;  Get comma or end
;  z=1 if comma, z=0 if end
;
;
;
;  Get integer constant
;  ebx = constant
;
;
;
;  Get 'step' or end
;  z=1 if 'step', z=0 if end
;
;
;
;  Get pipe or end
;  z=1 if pipe, z=0 if end
;
;
;
;  Scan to ']'
;
;
;
;  Check for ternary/binary/unary/compare/float/alias operator
;  z=1 if type, z=0 if not type
;
;
;
;  Check for operator
;
;
;
;  Scan to right parenthesis
;
;
;
;  Scan to end of line
;
;
;
;  Check for local symbol
;  c=0 if local
;
;
;
;  Get obj pub/con symbol
;  eax[31:24] must hold obj id
;  on exit, al = type_objpub/type_con/type_con_float, ebx = value, z=1 if type_objpub
;
;
;
;  Get symbol
;  c=0 if symbol with length in ecx
;
;
;
;  Get filename into symbol
;
;
;
;  Check for alignw/alignl
;  al = type
;  ebx = value
;  if alignw/alignl, z=1 and ecx=01b/11b
;
;
;
;  Check for element type
;  z=1 if match, z=0 if not match
;
;
;
;  Check index - [exp]
;  z=1 if index with exp ptr in eax
;  z=0 if no index
;
;
;
;  Skip index - [exp]
;
;
;
;  Check for plus
;  z=1 if '+' or '+.'
;
;
;
;  Convert -constant to constant
;
;
;
;  Convert op_sub to op_neg
;  z=1 if converted
;
;
;
;  Convert op_fsub to op_fneg
;  z=1 if converted
;
;
;
;  Enter al/ax/eax into obj
;
;
;
;  Skip block
;
;
;
;  Skip range
;
;
;
;  Skip expression
;
;
;
;  Skip expression, checking for constant
;
;
;
;  Skip element
;
;
;
;  Compile out-of-sequence expression
;  eax must hold source ptr
;
;
;
;  Compile value/range
;  z=0 if value, z=1 if range
;
;
;
;  Get value/range
;  low value in eax and high (same) value in ebx
;
;
;
;  Compile any parameters - accommodates instructions/methods with multiple return values
;  ecx must hold parameter count (0+)
;
;
;
;  Compile parameters with no parentheses - accommodates instructions/methods with multiple +
;  ecx must hold parameter count (1+)
;
;
;
;  Compile parameters for method pointer - accommodates instructions/methods with multiple  +
;  on exit, ecx holds parameter count (0+)
;
;
;
;  Compile a parameter - accommodates instructions/methods with multiple return values
;  on exit, eax holds number of actual parameters compiled
;
;        rotxy/polxy/xypol
;        obj{[]}.method({params,...})
;        method({params,...})
;        var({params,...}):2+
;
;
;
;  Compile a parameter for SEND - accommodates methods with no return value
;  on exit, eax holds 0 or 1 for number of parameters on the stack
;
;        obj{[]}.method({params,...})
;        method({params,...})
;        var({params,...}){:1}
;
;
;
;  Check for var({params,...}){:returns}
;  al must hold type
;  on exit, z=1 if method with number of return values in ebx
;
;
;
;  Get method pointer variable - must be long/reg without bitfield
;
;
;
;  Get variable
;
;
;
;  Check variable
;  al must hold type
;  ebx must hold value
;  on exit, z=1 if variable with ecx/esi/edi set
;
;
;        ecx.31:22 = bitfield constant (5+5 bits)
;        ecx.19    = bitfield constant flag
;        ecx.18    = bitfield flag
;        ecx.17    = index flag
;        ecx.16    = size override flag
;        ch=type                                                                            +
;        cl=size (0=byte/default, 1=word in hub, 2=long in hub)
;        esi=address (reg/loc/var/dat/hub)
;        edi=ptr after variable (base/index/bitfield exp)
;
;
;        field - type_field
;        ------------------
;
;        FIELD[memfield]
;        FIELD[memfield][index]
;
;
;        register - type_register
;        ------------------------
;
;        regname
;        regname.[bitfield]
;        regname[index]
;        regname[index].[bitfield]
;
;
;        hub memory - type_loc_???? / type_var_???? / type_dat_???? / type_hub_????
;        --------------------------------------------------------------------------
;
;        hubname{.BYTE/WORD/LONG}
;        hubname{.BYTE/WORD/LONG}.[bitfield]
;        hubname{.BYTE/WORD/LONG}[index]
;        hubname{.BYTE/WORD/LONG}[index].[bitfield]
;
;
;        hub memory - type_size
;        ----------------------
;
;        BYTE/WORD/LONG[base]
;        BYTE/WORD/LONG[base].[bitfield]
;        BYTE/WORD/LONG[base][index]
;        BYTE/WORD/LONG[base][index].[bitfield]
;
;
;    19952           =00080000              var_bitfield_con        =       80000h
;    19953           =00040000              var_bitfield_flag       =       40000h
;    19954           =00020000              var_index_flag          =       20000h
;    19955           =00010000              var_size_override       =       10000h
;
;
;  Compile var
;  check_variable must have been called (ecx,esi,edi valid)
;  dl must hold operation (0=read, 1=write, 2=setup-assign)
;  dh must hold any assignment bytecode
;
;
;
;  Compile var operations
;
;
;
;  Compile constant
;  ebx must hold constant
;
;
;
;  Compile index - [exp]
;
;
;
;  Compile branch
;  al must hold branch instruction (bc_jmp/bc_jz/bc_jnz/bc_tjz/bc_djnz), ebx must hold      +
;
;
;
;  Compile rfvars value in eax
;
;
;
;  Compile rfvar value in eax
;
;
;
;  Enter data into pub/con list
;
;
;
; ************************************************************************
; *  Disassembler                                                        *
; ************************************************************************
;
;    20611           =0025                  flag_tab        =       37
;
;
;  Disassemble instruction
;
;
;
;  Print {#}d
;  Print d
;
;
;
;  Print (#)s
;
;
;
;  Print s branch
;
;
;
;  Print s ptr
;
;
;
;  Print flag
;
;
;
;  Print flag logic
;  ah = logic
;
;
;
;  Tab to cl
;
;
;
;  Print 20-bit address
;
;
;
;  Print address
;
;
;
;  Print hex value
;  eax = value
;  cl = digits
;
;
;
;  Print decimal value
;  al = value
;
;
;
;  Print MODCZ/register operand
;  ah = nibble
;
;
;
;  Data
;
;
;
; ************************************************************************
; *  DEBUG Display Parser                                                *
; ************************************************************************
;
;
;
;  Variables
;
;
;
;  Reset debug symbols
;
;
;
;  Parse debug string
;
;  Instance:     dd_dis
;                dd_unk  (unknown symbol, assigned dd_nam and debug_display_new, plus record+
;                dd_key | dd_num | dd_str
;                dd_end
;
;  Command:      dd_nam
;                dd_key | dd_num | dd_str
;                dd_end
;
;
;
;  Get next element from debug display at esi - al=type and ebx=value
;
;
;
;  Check for debug display symbol at esi
;  c=0 if symbol, type in al, value in ebx, esi points after symbol
;
;
;
;  Check for number at esi
;  c=0 if number, dd_num in al, value in ebx, esi points after number
;
;
;
;  Check for 'string' at esi
;  c=0 if string, address in ebx, esi points after string
;
;
;
;  Find debug display symbol in auto/name symbol table
;  symbol must hold name, terminated with 0
;  if found, eax=type and ebx=value
;  if not found, eax=0 (type_undefined) and ebx=0
;
;
;
;  Enter type (al) and value (ebx) into debug display record
;
;
;
; ************************************************************************
; *  Symbol Engine                                                       *
; ************************************************************************
;
;
;  Hash table index ($1000 elements):
;
;        long:   pointer to symbol record (0=no record)
;
;  Symbol records:
;
;        byte:   symbol length, including terminating zero
;        bytes:  symbol chrs + 0
;        long:   symbol value
;        byte:   symbol type
;        long:   pointer to next record (0=no record)
;
;
;  Variables
;
;
;
;  Enter auto symbols into hashed symbol table
;
;
;
;  Discover Spin2 level and enter associated symbols
;
;
;
;  Enter param symbols into hashed symbol table
;
;
;
;  Reset auto/main/local/inline symbols
;
;
;
;  Write auto/main/local/inline symbols
;
;
;
;  Enter symbol2 into symbol table
;  symbol2 must hold name, terminated with 0
;  al must hold type
;  ebx must hold value
;
;
;
;  Find symbol in param symbol table
;  symbol must hold name, terminated with 0
;  if found, eax=type and ebx=value
;  if not found, eax=0 (type_undefined) and ebx=0
;
;
;
;  Find symbol in auto/level/main/local/inline symbol table
;  symbol must hold name, terminated with 0
;  if found, eax=type and ebx=value
;  if not found, eax=0 (type_undefined) and ebx=0
;
;
;
;  Check for symbol
;  ebx must point to symbol table
;  ecx must hold symbol length
;  edx must hold symbol hash index
;  esi must point to symbol
;  if found, eax=type and ebx=value
;  if not found, eax=0 (type_undefined) and ebx=0
;
;
;
;  Hash symbol at esi
;  on exit:
;        ecx = symbol length, including terminating zero
;        edx = hash index
;
;
;
;  Backup symbol to symbol2
;
;
;
;  Get symbol length into ecx
;  edi must point to symbol
;
;
;
;  Enter symbol2 after printing it
;
;
;
;  Find non-word 3-chr symbol
;
;
;
;  Find non-word 2-chr symbol
;
;                syms    '-.',   type_op,        oc_fneg         (uses oc_fsub symbol)
;
;
;  Find non-word 1-chr symbol
;
;                syms    '-',    type_op,        oc_neg          (uses oc_sub symbol)
;
;
;  Automatic symbols
;
; assembly          +
;        sym     type_asm_inst,          ac_ror,         'ROR'           (declared as       +
;        sym     type_asm_inst,          ac_rol,         'ROL'           (declared as       +
;        sym     type_asm_inst,          ac_sar,         'SAR'           (declared as       +
;        sym     type_asm_inst,          ac_and,         'AND'           (declared as       +
;        sym     type_asm_inst,          ac_or,          'OR'            (declared as       +
;        sym     type_asm_inst,          ac_xor,         'XOR'           (declared as       +
;        sym     type_asm_inst,          ac_not,         'NOT'           (declared as       +
;        sym     type_asm_inst,          ac_abs,         'ABS'           (declared as       +
;        sym     type_asm_inst,          ac_zerox,       'ZEROX'         (declared as       +
;        sym     type_asm_inst,          ac_signx,       'SIGNX'         (declared as       +
;        sym     type_asm_inst,          ac_encod,       'ENCOD'         (declared as       +
;        sym     type_asm_inst,          ac_ones,        'ONES'          (declared as       +
;        sym     type_asm_inst,          ac_decod,       'DECOD'         (declared as       +
;        sym     type_asm_inst,          ac_bmask,       'BMASK'         (declared as       +
;        sym     type_asm_inst,          ac_sca,         'SCA'           (declared as       +
;        sym     type_asm_inst,          ac_scas,        'SCAS'          (declared as       +
;        sym     type_asm_inst,          ac_rqpin,       'RQPIN'         (declared as       +
;        sym     type_asm_inst,          ac_rdpin,       'RDPIN'         (declared as       +
;        sym     type_asm_inst,          ac_empty,       '<empty>'
;        sym     type_asm_inst,          ac_empty,       '<empty>'
;        sym     type_asm_inst,          ac_wrpin,       'WRPIN'         (declared as       +
;        sym     type_asm_inst,          ac_wxpin,       'WXPIN'         (declared as       +
;        sym     type_asm_inst,          ac_wypin,       'WYPIN'         (declared as       +
;        sym     type_asm_inst,          ac_coginit,     'COGINIT'       (declared as       +
;        sym     type_asm_inst,          ac_hubset,      'HUBSET'        (declared as       +
;        sym     type_asm_inst,          ac_cogid,       'COGID'         (declared as       +
;        sym     type_asm_inst,          ac_cogstop,     'COGSTOP'       (declared as       +
;        sym     type_asm_inst,          ac_locknew,     'LOCKNEW'       (declared as       +
;        sym     type_asm_inst,          ac_lockret,     'LOCKRET'       (declared as       +
;        sym     type_asm_inst,          ac_locktry,     'LOCKTRY'       (declared as       +
;        sym     type_asm_inst,          ac_lockrel,     'LOCKREL'       (declared as       +
;        sym     type_asm_inst,          ac_qlog,        'QLOG'          (declared as       +
;        sym     type_asm_inst,          ac_qexp,        'QEXP'          (declared as       +
;        sym     type_asm_inst,          ac_getct,       'GETCT'         (declared as       +
;        sym     type_asm_inst,          ac_getrnd,      'GETRND'        (declared as       +
;        sym     type_asm_inst,          ac_pollatn,     'POLLATN'       (declared as       +
;        sym     type_asm_inst,          ac_waitatn,     'WAITATN'       (declared as       +
;        sym     type_asm_inst,          ac_cogatn,      'COGATN'        (declared as       +
;        sym     type_asm_inst,          ac_rev,         'REV'           (declared as       +
;        sym     type_asm_inst,          ac_call,        'CALL'          (declared as       +
;        sym     type_asm_inst,          ac_akpin,       'AKPIN'         (declared as       +
; event/interrupt constants
;
;
; *********
; *  End  *
; *********
;
;	************************************************
;
;
ac_abs  0x00001EC8
ac_add  0x00000620
ac_addct1  0x0000014C
ac_addct2  0x0000014D
ac_addct3  0x0000014E
ac_addpix  0x00000148
ac_adds  0x00000628
ac_addsx  0x0000062C
ac_addx  0x00000624
ac_akpin  0x00011000
ac_allowi  0x0000E020
ac_altb  0x00002933
ac_altd  0x00002931
ac_altgb  0x0000292D
ac_altgn  0x0000292B
ac_altgw  0x0000292F
ac_alti  0x00002134
ac_altr  0x00002930
ac_alts  0x00002932
ac_altsb  0x0000292C
ac_altsn  0x0000292A
ac_altsw  0x0000292E
ac_and  0x000006A0
ac_andn  0x000006A4
ac_asmclk  0x00011800
ac_augd  0x0000B9F0
ac_augs  0x0000B9E0
ac_bitc  0x00000888
ac_bith  0x00000884
ac_bitl  0x00000880
ac_bitnc  0x0000088C
ac_bitnot  0x0000089C
ac_bitnz  0x00000894
ac_bitrnd  0x00000898
ac_bitz  0x00000890
ac_blnpix  0x0000014A
ac_bmask  0x00001939
ac_brk  0x0000D036
ac_call  0x000099B4
ac_calla  0x000099B8
ac_callb  0x000099BC
ac_calld  0x0000A1C0
ac_callpa  0x00007168
ac_callpb  0x0000716A
ac_cmp  0x00000640
ac_cmpm  0x00000654
ac_cmpr  0x00000650
ac_cmps  0x00000648
ac_cmpsub  0x0000065C
ac_cmpsx  0x0000064C
ac_cmpx  0x00000644
ac_cogatn  0x0000D03F
ac_cogbrk  0x0000D035
ac_cogid  0x0000D401
ac_coginit  0x00006D9C
ac_cogstop  0x0000D003
ac_crcbit  0x0000013A
ac_crcnib  0x0000013B
ac_debug  0x00012836
ac_decmod  0x000006E4
ac_decod  0x00001938
ac_dirc  0x0000F042
ac_dirh  0x0000F041
ac_dirl  0x0000F040
ac_dirnc  0x0000F043
ac_dirnot  0x0000F047
ac_dirnz  0x0000F045
ac_dirrnd  0x0000F046
ac_dirz  0x0000F044
ac_djf  0x0000616E
ac_djnf  0x0000616F
ac_djnz  0x0000616D
ac_djz  0x0000616C
ac_drvc  0x0000F05A
ac_drvh  0x0000F059
ac_drvl  0x0000F058
ac_drvnc  0x0000F05B
ac_drvnot  0x0000F05F
ac_drvnz  0x0000F05D
ac_drvrnd  0x0000F05E
ac_drvz  0x0000F05C
ac_encod  0x00001EF0
ac_execf  0x0000D033
ac_fblock  0x00006992
ac_fge  0x00000660
ac_fges  0x00000668
ac_fle  0x00000664
ac_fles  0x0000066C
ac_fltc  0x0000F052
ac_flth  0x0000F051
ac_fltl  0x0000F050
ac_fltnc  0x0000F053
ac_fltnot  0x0000F057
ac_fltnz  0x0000F055
ac_fltrnd  0x0000F056
ac_fltz  0x0000F054
ac_getbrk  0x0000EE35
ac_getbyte  0x0000491C
ac_getct  0x0000C41A
ac_getnib  0x00003908
ac_getptr  0x0000C034
ac_getqx  0x0000C618
ac_getqy  0x0000C619
ac_getrnd  0x0000CE1B
ac_getscp  0x0000C071
ac_getword  0x00005926
ac_getxacc  0x0000C01E
ac_hubset  0x0000D000
ac_ijnz  0x00006171
ac_ijz  0x00006170
ac_incmod  0x000006E0
ac_jatn  0x0000A80E
ac_jct1  0x0000A801
ac_jct2  0x0000A802
ac_jct3  0x0000A803
ac_jfbw  0x0000A809
ac_jint  0x0000A800
ac_jmp  0x000091B0
ac_jmprel  0x0000D030
ac_jnatn  0x0000A81E
ac_jnct1  0x0000A811
ac_jnct2  0x0000A812
ac_jnct3  0x0000A813
ac_jnfbw  0x0000A819
ac_jnint  0x0000A810
ac_jnpat  0x0000A818
ac_jnqmt  0x0000A81F
ac_jnse1  0x0000A814
ac_jnse2  0x0000A815
ac_jnse3  0x0000A816
ac_jnse4  0x0000A817
ac_jnxfi  0x0000A81B
ac_jnxmt  0x0000A81A
ac_jnxrl  0x0000A81D
ac_jnxro  0x0000A81C
ac_jpat  0x0000A808
ac_jqmt  0x0000A80F
ac_jse1  0x0000A804
ac_jse2  0x0000A805
ac_jse3  0x0000A806
ac_jse4  0x0000A807
ac_jxfi  0x0000A80B
ac_jxmt  0x0000A80A
ac_jxrl  0x0000A80D
ac_jxro  0x0000A80C
ac_loc  0x0000B1D0
ac_locknew  0x0000C404
ac_lockrel  0x0000D407
ac_lockret  0x0000D005
ac_locktry  0x0000D406
ac_mergeb  0x0000C061
ac_mergew  0x0000C063
ac_mixpix  0x0000014B
ac_modc  0x0000DC6F
ac_modcz  0x0000DE6F
ac_modz  0x0000DA6F
ac_mov  0x000006C0
ac_movbyts  0x0000013F
ac_mul  0x00000340
ac_mulpix  0x00000149
ac_muls  0x00000342
ac_muxc  0x000006B0
ac_muxnc  0x000006B4
ac_muxnibs  0x0000013D
ac_muxnits  0x0000013C
ac_muxnz  0x000006BC
ac_muxq  0x0000013E
ac_muxz  0x000006B8
ac_neg  0x00001ECC
ac_negc  0x00001ED0
ac_negnc  0x00001ED4
ac_negnz  0x00001EDC
ac_negz  0x00001ED8
ac_nixint1  0x0000E025
ac_nixint2  0x0000E026
ac_nixint3  0x0000E027
ac_nop  0x00012000
ac_not  0x00001EC4
ac_ones  0x00001EF4
ac_or  0x000006A8
ac_outc  0x0000F04A
ac_outh  0x0000F049
ac_outl  0x0000F048
ac_outnc  0x0000F04B
ac_outnot  0x0000F04F
ac_outnz  0x0000F04D
ac_outrnd  0x0000F04E
ac_outz  0x0000F04C
ac_pollatn  0x0000E60E
ac_pollct1  0x0000E601
ac_pollct2  0x0000E602
ac_pollct3  0x0000E603
ac_pollfbw  0x0000E609
ac_pollint  0x0000E600
ac_pollpat  0x0000E608
ac_pollqmt  0x0000E60F
ac_pollse1  0x0000E604
ac_pollse2  0x0000E605
ac_pollse3  0x0000E606
ac_pollse4  0x0000E607
ac_pollxfi  0x0000E60B
ac_pollxmt  0x0000E60A
ac_pollxrl  0x0000E60D
ac_pollxro  0x0000E60C
ac_pop  0x0000C62B
ac_popa  0x00010602
ac_popb  0x00010603
ac_push  0x0000D02A
ac_pusha  0x00010000
ac_pushb  0x00010001
ac_qdiv  0x000069A2
ac_qexp  0x0000D00F
ac_qfrac  0x000069A4
ac_qlog  0x0000D00E
ac_qmul  0x000069A0
ac_qrotate  0x000069A8
ac_qsqrt  0x000069A6
ac_qvector  0x000069AA
ac_rcl  0x00000614
ac_rcr  0x00000610
ac_rczl  0x0000C66B
ac_rczr  0x0000C66A
ac_rdbyte  0x00007F58
ac_rdfast  0x0000698E
ac_rdlong  0x00007F60
ac_rdlut  0x00007F54
ac_rdpin  0x00000551
ac_rdword  0x00007F5C
ac_rep  0x0000899A
ac_resi0  0x00010807
ac_resi1  0x00010808
ac_resi2  0x00010809
ac_resi3  0x0001080A
ac_ret  0x00010E00
ac_reta  0x00010E01
ac_retb  0x00010E02
ac_reti0  0x00010803
ac_reti1  0x00010804
ac_reti2  0x00010805
ac_reti3  0x00010806
ac_rev  0x0000C069
ac_rfbyte  0x0000C610
ac_rflong  0x0000C612
ac_rfvar  0x0000C613
ac_rfvars  0x0000C614
ac_rfword  0x0000C611
ac_rgbexp  0x0000C067
ac_rgbsqz  0x0000C066
ac_rol  0x00000604
ac_rolbyte  0x00004920
ac_rolnib  0x00003910
ac_rolword  0x00005928
ac_ror  0x00000600
ac_rqpin  0x00000550
ac_sal  0x0000061C
ac_sar  0x00000618
ac_sca  0x00000344
ac_scas  0x00000346
ac_setbyte  0x00004118
ac_setcfrq  0x0000D03B
ac_setci  0x0000D039
ac_setcmod  0x0000D03C
ac_setcq  0x0000D03A
ac_setcy  0x0000D038
ac_setd  0x00000136
ac_setdacs  0x0000D01C
ac_setint1  0x0000D025
ac_setint2  0x0000D026
ac_setint3  0x0000D027
ac_setluts  0x0000D037
ac_setnib  0x00003100
ac_setpat  0x0000697E
ac_setpiv  0x0000D03D
ac_setpix  0x0000D03E
ac_setq  0x0000D028
ac_setq2  0x0000D029
ac_setr  0x00000135
ac_sets  0x00000137
ac_setscp  0x0000D070
ac_setse1  0x0000D020
ac_setse2  0x0000D021
ac_setse3  0x0000D022
ac_setse4  0x0000D023
ac_setword  0x00005124
ac_setxfrq  0x0000D01D
ac_seussf  0x0000C064
ac_seussr  0x0000C065
ac_shl  0x0000060C
ac_shr  0x00000608
ac_signx  0x000006EC
ac_skip  0x0000D031
ac_skipf  0x0000D032
ac_splitb  0x0000C060
ac_splitw  0x0000C062
ac_stalli  0x0000E021
ac_sub  0x00000630
ac_subr  0x00000658
ac_subs  0x00000638
ac_subsx  0x0000063C
ac_subx  0x00000634
ac_sumc  0x00000670
ac_sumnc  0x00000674
ac_sumnz  0x0000067C
ac_sumz  0x00000678
ac_test  0x00001EF8
ac_testb  0x00001080
ac_testbn  0x00001084
ac_testn  0x000006FC
ac_testp  0x0000F840
ac_testpn  0x0000F841
ac_tjf  0x00006174
ac_tjnf  0x00006175
ac_tjns  0x00006177
ac_tjnz  0x00006173
ac_tjs  0x00006176
ac_tjv  0x00006178
ac_tjz  0x00006172
ac_trgint1  0x0000E022
ac_trgint2  0x0000E023
ac_trgint3  0x0000E024
ac_waitatn  0x0000E61E
ac_waitct1  0x0000E611
ac_waitct2  0x0000E612
ac_waitct3  0x0000E613
ac_waitfbw  0x0000E619
ac_waitint  0x0000E610
ac_waitpat  0x0000E618
ac_waitse1  0x0000E614
ac_waitse2  0x0000E615
ac_waitse3  0x0000E616
ac_waitse4  0x0000E617
ac_waitx  0x0000D61F
ac_waitxfi  0x0000E61B
ac_waitxmt  0x0000E61A
ac_waitxrl  0x0000E61D
ac_waitxro  0x0000E61C
ac_wfbyte  0x0000D015
ac_wflong  0x0000D017
ac_wfword  0x0000D016
ac_wmlong  0x0000794F
ac_wrbyte  0x00008188
ac_wrc  0x0000C06C
ac_wrfast  0x00006990
ac_wrlong  0x0000818C
ac_wrlut  0x00008186
ac_wrnc  0x0000C06D
ac_wrnz  0x0000C06F
ac_wrpin  0x00006980
ac_wrword  0x0000818A
ac_wrz  0x0000C06E
ac_wxpin  0x00006982
ac_wypin  0x00006984
ac_xcont  0x00006998
ac_xinit  0x00006994
ac_xor  0x000006AC
ac_xoro32  0x0000C068
ac_xstop  0x0001080B
ac_xzero  0x00006996
ac_zerox  0x000006E8
;
bc_abort_0  0x00000006
bc_abort_arg  0x00000007
bc_abs  0x0000007A
bc_abs_write  0x00000093
bc_abs_write_push  0x000000BA
bc_add  0x0000008A
bc_add_pbase  0x00000024
bc_add_write  0x000000A3
bc_add_write_push  0x000000CA
bc_addbits  0x00000094
bc_addbits_write  0x000000AD
bc_addbits_write_push  0x000000D4
bc_addpins  0x00000095
bc_addpins_write  0x000000AE
bc_addpins_write_push  0x000000D5
bc_akpin  0x00000040
bc_bitand  0x0000008F
bc_bitand_write  0x000000A8
bc_bitand_write_push  0x000000CF
bc_bitnot  0x00000078
bc_bitnot_write  0x00000091
bc_bitnot_write_push  0x000000B8
bc_bitor  0x00000091
bc_bitor_write  0x000000AA
bc_bitor_write_push  0x000000D1
bc_bitrange  0x0000009F
bc_bitxor  0x00000090
bc_bitxor_write  0x000000A9
bc_bitxor_write_push  0x000000D0
bc_bmask  0x0000007D
bc_bmask_write  0x00000096
bc_bmask_write_push  0x000000BD
bc_bytefill  0x0000006C
bc_bytemove  0x0000006A
bc_call  0x00000064
bc_call_obj_sub  0x00000008
bc_call_obji_sub  0x00000009
bc_call_ptr  0x0000000B
bc_call_recv  0x0000000C
bc_call_send  0x0000000D
bc_call_send_bytes  0x0000000E
bc_call_sub  0x0000000A
bc_case_done  0x0000001E
bc_case_fast_done  0x0000001B
bc_case_fast_init  0x0000001A
bc_case_range  0x0000001D
bc_case_value  0x0000001C
bc_clkset  0x00000056
bc_cogatn  0x0000002E
bc_cogchk  0x0000005C
bc_cogid  0x00000028
bc_coginit  0x00000025
bc_coginit_push  0x00000026
bc_cogspin  0x0000005A
bc_cogstop  0x00000027
bc_con_n  0x000000A0
bc_con_rfbyte  0x00000044
bc_con_rfbyte_bmask  0x0000004B
bc_con_rfbyte_bmask_not  0x0000004C
bc_con_rfbyte_decod  0x00000049
bc_con_rfbyte_decod_not  0x0000004A
bc_con_rfbyte_not  0x00000045
bc_con_rflong  0x00000048
bc_con_rfword  0x00000046
bc_con_rfword_not  0x00000047
bc_debug  0x00000043
bc_decod  0x0000007C
bc_decod_write  0x00000095
bc_decod_write_push  0x000000BC
bc_div  0x00000097
bc_div_write  0x000000B0
bc_div_write_push  0x000000D7
bc_divu  0x00000098
bc_divu_write  0x000000B1
bc_divu_write_push  0x000000D8
bc_djnz  0x00000016
bc_drop  0x00000000
bc_drop_push  0x00000001
bc_drop_trap  0x00000002
bc_drop_trap_push  0x00000003
bc_e  0x00000070
bc_encod  0x0000007B
bc_encod_write  0x00000094
bc_encod_write_push  0x000000BB
bc_fabs  0x00000096
bc_fadd  0x0000009A
bc_fdiv  0x000000A0
bc_fe  0x000000A8
bc_fge  0x00000092
bc_fge_write  0x000000AB
bc_fge_write_push  0x000000D2
bc_fgt  0x000000A4
bc_fgte  0x000000AC
bc_fle  0x00000093
bc_fle_write  0x000000AC
bc_fle_write_push  0x000000D3
bc_float  0x000000B2
bc_flt  0x000000A2
bc_flte  0x000000AA
bc_fmul  0x0000009E
bc_fne  0x000000A6
bc_fneg  0x00000094
bc_frac  0x0000009D
bc_frac_write  0x000000B6
bc_frac_write_push  0x000000DD
bc_fsqrt  0x00000098
bc_fsub  0x0000009C
bc_get_addr  0x0000007F
bc_get_field  0x0000007E
bc_getcrc  0x0000007C
bc_getct  0x00000032
bc_getms  0x00000082
bc_getregs  0x00000066
bc_getrnd  0x00000031
bc_getsec  0x00000084
bc_gt  0x00000074
bc_gte  0x00000072
bc_gteu  0x00000073
bc_gtu  0x00000075
bc_hub_bytecode  0x00000019
bc_hubset  0x00000054
bc_inline  0x0000005E
bc_jmp  0x00000012
bc_jnz  0x00000014
bc_jz  0x00000013
bc_lockchk  0x0000002D
bc_locknew  0x00000029
bc_lockrel  0x0000002C
bc_lockret  0x0000002A
bc_locktry  0x0000002B
bc_logand  0x0000008C
bc_logand_write  0x000000A5
bc_logand_write_push  0x000000CC
bc_lognot  0x00000077
bc_lognot_write  0x00000090
bc_lognot_write_push  0x000000B7
bc_logor  0x0000008E
bc_logor_write  0x000000A7
bc_logor_write_push  0x000000CE
bc_logxor  0x0000008D
bc_logxor_write  0x000000A6
bc_logxor_write_push  0x000000CD
bc_longfill  0x00000074
bc_longmove  0x00000072
bc_look_done  0x00000023
bc_lookdown_range  0x00000022
bc_lookdown_value  0x00000020
bc_lookup_range  0x00000021
bc_lookup_value  0x0000001F
bc_lt  0x0000006C
bc_lte  0x0000006E
bc_ltegt  0x00000076
bc_lteu  0x0000006F
bc_ltu  0x0000006D
bc_mptr_obj_sub  0x0000000F
bc_mptr_obji_sub  0x00000010
bc_mptr_sub  0x00000011
bc_mul  0x00000096
bc_mul_write  0x000000AF
bc_mul_write_push  0x000000D6
bc_muldiv64  0x00000086
bc_nan  0x00000092
bc_ne  0x00000071
bc_neg  0x00000079
bc_neg_write  0x00000092
bc_neg_write_push  0x000000B9
bc_ones  0x0000007E
bc_ones_write  0x00000097
bc_ones_write_push  0x000000BE
bc_pinclear  0x0000003C
bc_pinfloat  0x00000039
bc_pinhigh  0x00000037
bc_pinlow  0x00000036
bc_pinread  0x0000003A
bc_pinstart  0x0000003B
bc_pintoggle  0x00000038
bc_pinwrite  0x00000035
bc_pollatn  0x0000002F
bc_pollct  0x00000033
bc_polxy  0x0000008E
bc_pop  0x00000017
bc_pop_rfvar  0x00000018
bc_qcos  0x0000008A
bc_qexp  0x00000081
bc_qexp_write  0x0000009A
bc_qexp_write_push  0x000000C1
bc_qlog  0x00000080
bc_qlog_write  0x00000099
bc_qlog_write_push  0x000000C0
bc_qsin  0x00000088
bc_rdpin  0x00000041
bc_read  0x00000080
bc_read_clkfreq  0x00000058
bc_read_local_0_15  0x000000E0
bc_regexec  0x00000060
bc_regload  0x00000062
bc_rem  0x00000099
bc_rem_write  0x000000B2
bc_rem_write_push  0x000000D9
bc_remu  0x0000009A
bc_remu_write  0x000000B3
bc_remu_write_push  0x000000DA
bc_repeat_var_init  0x0000007C
bc_repeat_var_init_1  0x0000007B
bc_repeat_var_init_n  0x0000007A
bc_repeat_var_loop  0x0000007D
bc_return_args  0x00000005
bc_return_results  0x00000004
bc_rev  0x00000087
bc_rev_write  0x000000A0
bc_rev_write_push  0x000000C7
bc_rol  0x00000086
bc_rol_write  0x0000009F
bc_rol_write_push  0x000000C6
bc_ror  0x00000085
bc_ror_write  0x0000009E
bc_ror_write_push  0x000000C5
bc_rotxy  0x0000008C
bc_round  0x000000AE
bc_rqpin  0x00000042
bc_sar  0x00000084
bc_sar_write  0x0000009D
bc_sar_write_push  0x000000C4
bc_sca  0x0000009B
bc_sca_write  0x000000B4
bc_sca_write_push  0x000000DB
bc_scas  0x0000009C
bc_scas_write  0x000000B5
bc_scas_write_push  0x000000DC
bc_setregs  0x00000068
bc_setup_bfield_0_31  0x000000E0
bc_setup_bfield_pop  0x000000DE
bc_setup_bfield_rfvar  0x000000DF
bc_setup_byte_dbase  0x00000053
bc_setup_byte_dbase_pi  0x00000056
bc_setup_byte_pa  0x00000066
bc_setup_byte_pb_pi  0x00000063
bc_setup_byte_pbase  0x00000051
bc_setup_byte_pbase_pi  0x00000054
bc_setup_byte_vbase  0x00000052
bc_setup_byte_vbase_pi  0x00000055
bc_setup_field_p  0x0000004D
bc_setup_field_pi  0x0000004E
bc_setup_local_0_15  0x000000D0
bc_setup_long_dbase  0x0000005F
bc_setup_long_dbase_pi  0x00000062
bc_setup_long_pa  0x00000068
bc_setup_long_pb_pi  0x00000065
bc_setup_long_pbase  0x0000005D
bc_setup_long_pbase_pi  0x00000060
bc_setup_long_vbase  0x0000005E
bc_setup_long_vbase_pi  0x00000061
bc_setup_reg  0x0000004F
bc_setup_reg_1D8_1F8  0x000000B0
bc_setup_reg_pi  0x00000050
bc_setup_var_0_15  0x000000C0
bc_setup_word_dbase  0x00000059
bc_setup_word_dbase_pi  0x0000005C
bc_setup_word_pa  0x00000067
bc_setup_word_pb_pi  0x00000064
bc_setup_word_pbase  0x00000057
bc_setup_word_pbase_pi  0x0000005A
bc_setup_word_vbase  0x00000058
bc_setup_word_vbase_pi  0x0000005B
bc_shl  0x00000083
bc_shl_write  0x0000009C
bc_shl_write_push  0x000000C3
bc_shr  0x00000082
bc_shr_write  0x0000009B
bc_shr_write_push  0x000000C2
bc_signx  0x00000089
bc_signx_write  0x000000A2
bc_signx_write_push  0x000000C9
bc_sqrt  0x0000007F
bc_sqrt_write  0x00000098
bc_sqrt_write_push  0x000000BF
bc_strcomp  0x00000078
bc_strcopy  0x0000007A
bc_string  0x0000009E
bc_strsize  0x00000076
bc_sub  0x0000008B
bc_sub_write  0x000000A4
bc_sub_write_push  0x000000CB
bc_ternary  0x0000006B
bc_tjz  0x00000015
bc_trunc  0x000000B0
bc_var_bitnot  0x0000008B
bc_var_bitnot_push  0x0000008C
bc_var_dec  0x00000084
bc_var_inc  0x00000083
bc_var_lognot  0x00000089
bc_var_lognot_push  0x0000008A
bc_var_postdec_push  0x00000088
bc_var_postinc_push  0x00000087
bc_var_predec_push  0x00000086
bc_var_preinc_push  0x00000085
bc_var_rnd  0x0000008E
bc_var_rnd_push  0x0000008F
bc_var_swap  0x0000008D
bc_waitatn  0x00000030
bc_waitct  0x00000034
bc_waitms  0x00000080
bc_waitus  0x0000007E
bc_wordfill  0x00000070
bc_wordmove  0x0000006E
bc_write  0x00000081
bc_write_local_0_15  0x000000F0
bc_write_push  0x00000082
bc_wrpin  0x0000003D
bc_wxpin  0x0000003E
bc_wypin  0x0000003F
bc_xypol  0x00000090
bc_zerox  0x00000088
bc_zerox_write  0x000000A1
bc_zerox_write_push  0x000000C8
;
block_con  0x00000000
block_dat  0x00000005
block_obj  0x00000001
block_pri  0x00000004
block_pub  0x00000003
block_var  0x00000002
;
dc_asm  0x00000001
dc_chr  0x00000005
dc_cogn  0x00000004
dc_dly  0x00000007
dc_end  0x00000000
dc_if  0x00000002
dc_ifnot  0x00000003
dc_pc_key  0x00000008
dc_pc_mouse  0x00000009
dc_str  0x00000006
;
dd_dis  0x00000001
dd_dis_bitmap  0x00000007
dd_dis_fft  0x00000003
dd_dis_logic  0x00000000
dd_dis_midi  0x00000008
dd_dis_plot  0x00000005
dd_dis_scope  0x00000001
dd_dis_scope_xy  0x00000002
dd_dis_spectro  0x00000004
dd_dis_term  0x00000006
dd_end  0x00000000
dd_key  0x00000003
dd_key_alt  0x00000029
dd_key_auto  0x0000002A
dd_key_backcolor  0x0000002B
dd_key_black  0x00000000
dd_key_blue  0x00000003
dd_key_box  0x0000002C
dd_key_bytes_1bit  0x00000026
dd_key_bytes_2bit  0x00000027
dd_key_bytes_4bit  0x00000028
dd_key_cartesian  0x0000002D
dd_key_channel  0x0000002E
dd_key_circle  0x0000002F
dd_key_clear  0x00000030
dd_key_close  0x00000031
dd_key_color  0x00000032
dd_key_cyan  0x00000005
dd_key_depth  0x00000033
dd_key_dot  0x00000034
dd_key_dotsize  0x00000035
dd_key_gray  0x00000009
dd_key_green  0x00000004
dd_key_hidexy  0x00000036
dd_key_holdoff  0x00000037
dd_key_hsv16  0x00000018
dd_key_hsv16w  0x00000019
dd_key_hsv16x  0x0000001A
dd_key_hsv8  0x00000011
dd_key_hsv8w  0x00000012
dd_key_hsv8x  0x00000013
dd_key_line  0x00000038
dd_key_linesize  0x00000039
dd_key_logscale  0x0000003A
dd_key_longs_16bit  0x00000021
dd_key_longs_1bit  0x0000001D
dd_key_longs_2bit  0x0000001E
dd_key_longs_4bit  0x0000001F
dd_key_longs_8bit  0x00000020
dd_key_luma8  0x0000000E
dd_key_luma8w  0x0000000F
dd_key_luma8x  0x00000010
dd_key_lut1  0x0000000A
dd_key_lut2  0x0000000B
dd_key_lut4  0x0000000C
dd_key_lut8  0x0000000D
dd_key_lutcolors  0x0000003B
dd_key_mag  0x0000003C
dd_key_magenta  0x00000007
dd_key_obox  0x0000003D
dd_key_opacity  0x0000003E
dd_key_orange  0x00000002
dd_key_origin  0x0000003F
dd_key_oval  0x00000040
dd_key_pc_key  0x00000041
dd_key_pc_mouse  0x00000042
dd_key_polar  0x00000043
dd_key_pos  0x00000044
dd_key_precise  0x00000045
dd_key_range  0x00000046
dd_key_rate  0x00000047
dd_key_red  0x00000006
dd_key_rgb16  0x0000001B
dd_key_rgb24  0x0000001C
dd_key_rgb8  0x00000017
dd_key_rgbi8  0x00000014
dd_key_rgbi8w  0x00000015
dd_key_rgbi8x  0x00000016
dd_key_samples  0x00000048
dd_key_save  0x00000049
dd_key_scroll  0x0000004A
dd_key_set  0x0000004B
dd_key_signed  0x0000004C
dd_key_size  0x0000004D
dd_key_spacing  0x0000004E
dd_key_sparse  0x0000004F
dd_key_sprite  0x00000050
dd_key_spritedef  0x00000051
dd_key_text  0x00000052
dd_key_textangle  0x00000053
dd_key_textsize  0x00000054
dd_key_textstyle  0x00000055
dd_key_title  0x00000056
dd_key_trace  0x00000057
dd_key_trigger  0x00000058
dd_key_update  0x00000059
dd_key_white  0x00000001
dd_key_window  0x0000005A
dd_key_words_1bit  0x00000022
dd_key_words_2bit  0x00000023
dd_key_words_4bit  0x00000024
dd_key_words_8bit  0x00000025
dd_key_yellow  0x00000008
dd_nam  0x00000002
dd_num  0x00000004
dd_str  0x00000005
dd_unk  0x00000006
;
dir_alignl  0x00000002
dir_alignw  0x00000001
dir_fit  0x00000006
dir_org  0x00000003
dir_orgf  0x00000004
dir_orgh  0x00000000
dir_res  0x00000005
;
disop_addr20  0x00000000
disop_aug  0x00000001
disop_cz  0x00000002
disop_d  0x00000003
disop_dc  0x00000004
disop_dc_modc  0x00000005
disop_dcz  0x00000006
disop_dcz_modcz  0x00000007
disop_ds  0x00000008
disop_ds_alt  0x00000009
disop_ds_alti  0x0000000A
disop_ds_branch  0x0000000B
disop_ds_byte  0x0000000C
disop_ds_nib  0x0000000D
disop_ds_ptr  0x0000000E
disop_ds_single  0x0000000F
disop_ds_word  0x00000010
disop_dsc  0x00000011
disop_dscz  0x00000012
disop_dscz_bit  0x00000013
disop_dscz_bit_log  0x00000014
disop_dscz_branch  0x00000015
disop_dscz_ptr  0x00000016
disop_dscz_single  0x00000017
disop_dsz  0x00000018
disop_dz_modz  0x00000019
disop_l  0x0000001A
disop_lc  0x0000001B
disop_lcz  0x0000001C
disop_lcz_pin  0x0000001D
disop_lcz_pin_log  0x0000001E
disop_ls  0x0000001F
disop_ls_branch  0x00000020
disop_ls_pin  0x00000021
disop_ls_ptr  0x00000022
disop_lsc  0x00000023
disop_lx  0x00000024
disop_none  0x00000025
disop_p_addr20  0x00000026
disop_s  0x00000027
disop_s_branch  0x00000028
disop_s_pin  0x00000029
;
fc_akpin  0x00004140
fc_bytefill  0x0000836C
fc_bytemove  0x0000836A
fc_call  0x00008164
fc_clkset  0x00008256
fc_cogatn  0x0000012E
fc_cogchk  0x0000895C
fc_cogid  0x00000828
fc_coginit  0x00000325
fc_coginit_push  0x00000B26
fc_cogstop  0x00000127
fc_float  0x000089B2
fc_getcrc  0x00008B7C
fc_getct  0x00000832
fc_getms  0x00008882
fc_getregs  0x00008366
fc_getrnd  0x00000831
fc_getsec  0x00008884
fc_hubset  0x00008154
fc_lockchk  0x0000092D
fc_locknew  0x00000829
fc_lockrel  0x0000012C
fc_lockret  0x0000012A
fc_locktry  0x0000092B
fc_longfill  0x00008374
fc_longmove  0x00008372
fc_muldiv64  0x00008B86
fc_nan  0x00008992
fc_pinclear  0x0000413C
fc_pinfloat  0x00004139
fc_pinhigh  0x00004137
fc_pinlow  0x00004136
fc_pinread  0x0000493A
fc_pinstart  0x0000443B
fc_pintoggle  0x00004138
fc_pinwrite  0x00004235
fc_pollatn  0x0000082F
fc_pollct  0x00000933
fc_polxy  0x0000928E
fc_qcos  0x00008B8A
fc_qsin  0x00008B88
fc_rdpin  0x00000941
fc_regexec  0x00008160
fc_regload  0x00008162
fc_rotxy  0x0000938C
fc_round  0x000089AE
fc_rqpin  0x00000942
fc_setregs  0x00008368
fc_strcomp  0x00008A78
fc_strcopy  0x0000837A
fc_strsize  0x00008976
fc_trunc  0x000089B0
fc_waitatn  0x00000030
fc_waitct  0x00000134
fc_waitms  0x00008180
fc_waitus  0x0000817E
fc_wordfill  0x00008370
fc_wordmove  0x0000836E
fc_wrpin  0x0000423D
fc_wxpin  0x0000423E
fc_wypin  0x0000423F
fc_xypol  0x00009290
;
if_always  0x0000000F
if_c  0x0000000C
if_c_and_nz  0x00000004
if_c_and_z  0x00000008
if_c_eq_z  0x00000009
if_c_ne_z  0x00000006
if_c_or_nz  0x0000000D
if_c_or_z  0x0000000E
if_nc  0x00000003
if_nc_and_nz  0x00000001
if_nc_and_z  0x00000002
if_nc_or_nz  0x00000007
if_nc_or_z  0x0000000B
if_never  0x00000000
if_nz  0x00000005
if_z  0x0000000A
;
info_con  0x00000000
info_con_float  0x00000001
info_dat  0x00000002
info_dat_symbol  0x00000003
info_pri  0x00000005
info_pub  0x00000004
;
oc_abs  0x1C7A0003
oc_add  0x1A8A0622
oc_addbits  0x0A940828
oc_addpins  0x0A950829
oc_bitand  0x0A8F0215
oc_bitnot  0x0C780000
oc_bitor  0x0A910417
oc_bitxor  0x0A900316
oc_bmask  0x0C7D0007
oc_decod  0x0C7C0006
oc_div  0x1A97051A
oc_divu  0x0A98051C
oc_e  0x12700930
oc_encod  0x0C7B0005
oc_fabs  0x54960004
oc_fadd  0x529A0623
oc_fdiv  0x52A0051B
oc_fe  0x52A80931
oc_fge  0x1A920726
oc_fgt  0x52A40938
oc_fgte  0x52AC0935
oc_fle  0x1A930727
oc_flt  0x52A2092B
oc_flte  0x52AA092E
oc_fmul  0x529E0519
oc_fne  0x52A60933
oc_fneg  0x54940002
oc_frac  0x0A9D0521
oc_fsqrt  0x5498000A
oc_fsub  0x529C0625
oc_gt  0x12740937
oc_gte  0x12720934
oc_gteu  0x02730936
oc_gtu  0x02750939
oc_logand  0x2A8C0B3C
oc_logand_name  0x0A8C0B3C
oc_lognot  0x2C770A3B
oc_lognot_name  0x0C770A3B
oc_logor  0x2A8E0D3E
oc_logor_name  0x0A8E0D3E
oc_logxor  0x2A8D0C3D
oc_logxor_name  0x0A8D0C3D
oc_lt  0x126C092A
oc_lte  0x126E092D
oc_ltegt  0x1276093A
oc_lteu  0x026F092F
oc_ltu  0x026D092C
oc_mul  0x1A960518
oc_ne  0x12710932
oc_neg  0x1C790001
oc_ones  0x0C7E0008
oc_qexp  0x0C81000C
oc_qlog  0x0C80000B
oc_rem  0x0A99051D
oc_remu  0x0A9A051E
oc_rev  0x0A870112
oc_rol  0x0A860111
oc_ror  0x0A850110
oc_sar  0x0A84010F
oc_sca  0x0A9B051F
oc_scas  0x0A9C0520
oc_shl  0x0A83010E
oc_shr  0x0A82010D
oc_signx  0x0A890114
oc_sqrt  0x0C7F0009
oc_sub  0x1A8B0624
oc_ternary  0x09000E3F
oc_zerox  0x0A880113
;
op_abs  0x00000003
op_add  0x00000022
op_addbits  0x00000028
op_addpins  0x00000029
op_bitand  0x00000015
op_bitnot  0x00000000
op_bitor  0x00000017
op_bitxor  0x00000016
op_bmask  0x00000007
op_decod  0x00000006
op_div  0x0000001A
op_divu  0x0000001C
op_e  0x00000030
op_encod  0x00000005
op_fabs  0x00000004
op_fadd  0x00000023
op_fdiv  0x0000001B
op_fe  0x00000031
op_fge  0x00000026
op_fgt  0x00000038
op_fgte  0x00000035
op_fle  0x00000027
op_flt  0x0000002B
op_flte  0x0000002E
op_fmul  0x00000019
op_fne  0x00000033
op_fneg  0x00000002
op_frac  0x00000021
op_fsqrt  0x0000000A
op_fsub  0x00000025
op_gt  0x00000037
op_gte  0x00000034
op_gteu  0x00000036
op_gtu  0x00000039
op_logand  0x0000003C
op_lognot  0x0000003B
op_logor  0x0000003E
op_logxor  0x0000003D
op_lt  0x0000002A
op_lte  0x0000002D
op_ltegt  0x0000003A
op_lteu  0x0000002F
op_ltu  0x0000002C
op_mul  0x00000018
op_ne  0x00000032
op_neg  0x00000001
op_ones  0x00000008
op_qexp  0x0000000C
op_qlog  0x0000000B
op_rem  0x0000001D
op_remu  0x0000001E
op_rev  0x00000012
op_rol  0x00000011
op_ror  0x00000010
op_sar  0x0000000F
op_sca  0x0000001F
op_scas  0x00000020
op_shl  0x0000000E
op_shr  0x0000000D
op_signx  0x00000014
op_sqrt  0x00000009
op_sub  0x00000024
op_ternary  0x0000003F
op_zerox  0x00000013
;
operand_akpin  0x00000022
operand_asmclk  0x00000023
operand_aug  0x00000017
operand_bitx  0x00000001
operand_call  0x00000013
operand_calld  0x00000014
operand_cz  0x0000001B
operand_d  0x00000018
operand_de  0x00000019
operand_debug  0x00000025
operand_ds  0x00000000
operand_ds1get  0x0000000B
operand_ds1set  0x0000000A
operand_ds2get  0x00000009
operand_ds2set  0x00000008
operand_ds3get  0x00000007
operand_ds3set  0x00000006
operand_dsj  0x0000000C
operand_dsp  0x0000000F
operand_du  0x00000003
operand_duii  0x00000004
operand_duiz  0x00000005
operand_getbrk  0x0000001D
operand_jmp  0x00000012
operand_jpoll  0x00000015
operand_l  0x0000001A
operand_loc  0x00000016
operand_ls  0x0000000D
operand_lsj  0x0000000E
operand_lsp  0x00000010
operand_nop  0x00000024
operand_pinop  0x0000001E
operand_pollwait  0x0000001C
operand_pushpop  0x00000020
operand_rep  0x00000011
operand_testb  0x00000002
operand_testp  0x0000001F
operand_xlat  0x00000021
;
pp_popa  0x00000002
pp_popb  0x00000003
pp_pusha  0x00000000
pp_pushb  0x00000001
;
type_asm_cond  0x00000043
type_asm_dir  0x00000042
type_asm_effect  0x00000045
type_asm_effect2  0x00000046
type_asm_end  0x00000041
type_asm_inst  0x00000044
type_assign  0x00000018
type_at  0x00000010
type_atat  0x00000011
type_back  0x00000009
type_block  0x0000001F
type_case  0x0000002A
type_case_fast  0x0000002B
type_colon  0x00000008
type_comma  0x00000005
type_con  0x00000048
type_con_float  0x00000049
type_conlstr  0x0000001E
type_constr  0x0000001D
type_dat_byte  0x00000051
type_dat_long  0x00000053
type_dat_long_res  0x00000054
type_dat_word  0x00000052
type_debug  0x0000003F
type_debug_cmd  0x00000040
type_dec  0x00000016
type_dollar  0x0000000C
type_dot  0x0000000E
type_dotdot  0x0000000F
type_else  0x00000029
type_elseif  0x00000027
type_elseifnot  0x00000028
type_end  0x0000005D
type_equal  0x00000006
type_field  0x00000020
type_file  0x00000024
type_float  0x0000001A
type_from  0x00000033
type_fvar  0x00000023
type_hub_byte  0x00000055
type_hub_long  0x00000057
type_hub_word  0x00000056
type_i_abort  0x00000039
type_i_cogspin  0x0000003B
type_i_flex  0x0000003C
type_i_look  0x0000003A
type_i_next_quit  0x00000037
type_i_return  0x00000038
type_if  0x00000025
type_ifnot  0x00000026
type_inc  0x00000015
type_left  0x00000001
type_leftb  0x00000003
type_loc_byte  0x0000004B
type_loc_long  0x0000004D
type_loc_word  0x0000004C
type_method  0x0000005C
type_obj  0x00000058
type_objcon  0x0000005A
type_objcon_float  0x0000005B
type_objpub  0x00000059
type_op  0x00000019
type_other  0x0000002C
type_percent  0x0000000D
type_pound  0x00000007
type_recv  0x0000003D
type_reg  0x00000047
type_register  0x0000004A
type_repeat  0x0000002D
type_repeat_count  0x0000002F
type_repeat_count_var  0x00000030
type_repeat_var  0x0000002E
type_right  0x00000002
type_rightb  0x00000004
type_rnd  0x00000017
type_round  0x0000001B
type_send  0x0000003E
type_size  0x00000021
type_size_fit  0x00000022
type_step  0x00000035
type_tick  0x0000000B
type_til  0x00000013
type_tiltil  0x00000014
type_to  0x00000034
type_trunc  0x0000001C
type_undefined  0x00000000
type_under  0x0000000A
type_until  0x00000032
type_upat  0x00000012
type_var_byte  0x0000004E
type_var_long  0x00000050
type_var_word  0x0000004F
type_while  0x00000031
type_with  0x00000036
;
unused1  0x00000069
;
unused2  0x0000006A
